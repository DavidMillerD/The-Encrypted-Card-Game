// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint8, externalEuint8, ebool} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

contract EncryptedCardGame is SepoliaConfig {
    enum GameState { Waiting, Playing, Finished }
    enum CardType { Eagle, Bear, Snake }

    struct Card {
        euint8 cardType; // 0: Eagle, 1: Bear, 2: Snake (encrypted)
        uint8 health;    // Health points (always 2)
        bool isAlive;    // Whether card is alive (not encrypted)
    }

    struct Player {
        address playerAddress;
        Card[6] cards;
        uint8 aliveCount; // Not encrypted
        bool hasJoined;
    }

    struct Game {
        GameState state;
        Player[2] players;
        uint8 playersJoined;
        uint8 currentRound;
        uint8[2] currentPlayedCards; // Indexes of cards played this round
        bool[2] hasPlayedCard; // Track if player has played card this round
        mapping(uint8 => euint8) battleResults; // round => result
        address winner;
    }

    uint256 public nextGameId;
    mapping(uint256 => Game) public games;
    mapping(address => uint256) public playerToGame; // Track which game a player is in
    
    event GameCreated(uint256 indexed gameId, address indexed creator);
    event PlayerJoined(uint256 indexed gameId, address indexed player, uint8 playerIndex);
    event GameStarted(uint256 indexed gameId);
    event CardPlayed(uint256 indexed gameId, address indexed player, uint8 round);
    event BattleResult(uint256 indexed gameId, uint8 round, uint8 winner);
    event GameEnded(uint256 indexed gameId, address winner);
    
    modifier gameExists(uint256 gameId) {
        require(gameId < nextGameId, "Game does not exist");
        _;
    }

    modifier onlyGamePlayer(uint256 gameId) {
        Game storage game = games[gameId];
        require(
            msg.sender == game.players[0].playerAddress ||
            msg.sender == game.players[1].playerAddress,
            "Not a player in this game"
        );
        _;
    }

    modifier onlyInGameState(uint256 gameId, GameState _state) {
        require(games[gameId].state == _state, "Invalid game state");
        _;
    }

    constructor() {
        nextGameId = 0;
    }

    function createGame() external returns (uint256) {
        require(playerToGame[msg.sender] == 0 || games[playerToGame[msg.sender]].state == GameState.Finished, "Already in a game");

        uint256 gameId = nextGameId++;
        Game storage newGame = games[gameId];
        newGame.state = GameState.Waiting;
        newGame.playersJoined = 0;
        newGame.currentRound = 0;

        playerToGame[msg.sender] = gameId;

        emit GameCreated(gameId, msg.sender);
        return gameId;
    }
    
    function joinGame(
        uint256 gameId,
        externalEuint8[6] calldata encryptedCardTypes,
        bytes calldata inputProof
    ) external gameExists(gameId) onlyInGameState(gameId, GameState.Waiting) {
        Game storage game = games[gameId];
        require(game.playersJoined < 2, "Game is full");
        require(!game.players[0].hasJoined || game.players[0].playerAddress != msg.sender, "Player already joined");
        require(!game.players[1].hasJoined || game.players[1].playerAddress != msg.sender, "Player already joined");
        require(playerToGame[msg.sender] == 0 || games[playerToGame[msg.sender]].state == GameState.Finished, "Already in another game");

        uint8 playerIndex = game.playersJoined;
        game.players[playerIndex].playerAddress = msg.sender;
        game.players[playerIndex].hasJoined = true;
        game.players[playerIndex].aliveCount = 6;

        playerToGame[msg.sender] = gameId;
        
        // Initialize player's cards
        for (uint8 i = 0; i < 6; i++) {
            euint8 cardType = FHE.fromExternal(encryptedCardTypes[i], inputProof);
            // Note: encryptedCardHealth is ignored, all cards have health = 2

            // Validate card type (0, 1, or 2)
            ebool validType1 = FHE.eq(cardType, 0);
            ebool validType2 = FHE.eq(cardType, 1);
            ebool validType3 = FHE.eq(cardType, 2);
            ebool isValidType = FHE.or(FHE.or(validType1, validType2), validType3);

            game.players[playerIndex].cards[i] = Card({
                cardType: FHE.select(isValidType, cardType, FHE.asEuint8(0)),
                health: 2, // All cards have health 2
                isAlive: true
            });

            // Set ACL permissions only for encrypted fields
            FHE.allowThis(game.players[playerIndex].cards[i].cardType);
            FHE.allow(game.players[playerIndex].cards[i].cardType, msg.sender);
        }

        game.playersJoined++;
        emit PlayerJoined(gameId, msg.sender, playerIndex);
        
        if (game.playersJoined == 2) {
            game.state = GameState.Playing;
            emit GameStarted(gameId);
        }
    }
    
    function playCard(
        uint256 gameId,
        uint8 cardIndex
    ) external gameExists(gameId) onlyGamePlayer(gameId) onlyInGameState(gameId, GameState.Playing) {
        uint8 playerIndex = (msg.sender == players[0].playerAddress) ? 0 : 1;
        
        euint8 cardIndex = FHE.fromExternal(encryptedCardIndex, inputProof);
        
        // Validate card index (0-5)
        ebool validIndex = FHE.le(cardIndex, 5);

        // Since isAlive is not encrypted, we'll validate the card later in battle
        // For now, just store the encrypted card index
        euint8 safeIndex = FHE.select(validIndex, cardIndex, FHE.asEuint8(0));
        
        // Store the played card index
        currentPlayedCards[playerIndex] = safeIndex;
        hasPlayedCard[playerIndex] = true;
        
        // Set ACL permissions
        FHE.allowThis(currentPlayedCards[playerIndex]);
        
        emit CardPlayed(msg.sender, currentRound);
        
        // If both players have played, resolve battle
        if (hasPlayedCard[0] && hasPlayedCard[1]) {
            resolveBattle();
        }
    }
    
    function resolveBattle() internal {
        // Get played cards using indexes
        
        // Get actual cards using FHE.select based on indexes
        euint8 actualCard1Type = getCardByIndex(0, currentPlayedCards[0]);
        euint8 actualCard1Health = getCardHealthByIndex(0, currentPlayedCards[0]);
        ebool actualCard1Alive = getCardAliveByIndex(0, currentPlayedCards[0]);
        
        euint8 actualCard2Type = getCardByIndex(1, currentPlayedCards[1]);
        euint8 actualCard2Health = getCardHealthByIndex(1, currentPlayedCards[1]);
        ebool actualCard2Alive = getCardAliveByIndex(1, currentPlayedCards[1]);
        
        // Check if both cards are alive
        ebool bothAlive = FHE.and(actualCard1Alive, actualCard2Alive);
        
        // Battle logic: Eagle(0) > Snake(2), Bear(1) > Eagle(0), Snake(2) > Bear(1)
        ebool card1Wins = calculateWinner(actualCard1Type, actualCard2Type, actualCard1Health, actualCard2Health);
        ebool card2Wins = calculateWinner(actualCard2Type, actualCard1Type, actualCard2Health, actualCard1Health);
        
        // Determine result: 0=draw, 1=player1 wins, 2=player2 wins
        euint8 result = FHE.select(
            FHE.and(bothAlive, card1Wins),
            FHE.asEuint8(1),
            FHE.select(
                FHE.and(bothAlive, card2Wins),
                FHE.asEuint8(2),
                FHE.asEuint8(0) // Draw or one card already dead
            )
        );
        
        // Update card status based on battle result
        updateCardStatus(result, currentPlayedCards[0], currentPlayedCards[1]);
        
        battleResults[currentRound] = result;
        FHE.allowThis(battleResults[currentRound]);
        FHE.allow(battleResults[currentRound], players[0].playerAddress);
        FHE.allow(battleResults[currentRound], players[1].playerAddress);
        
        emit BattleResult(currentRound, 0); // Note: We can't decrypt result here, so using 0 as placeholder
        
        currentRound++;
        
        // Reset played cards for next round
        hasPlayedCard[0] = false;
        hasPlayedCard[1] = false;
        
        // Check if game should end
        checkGameEnd();
    }
    
    function calculateWinner(
        euint8 attacker,
        euint8 defender,
        euint8 attackerHealth,
        euint8 defenderHealth
    ) internal returns (ebool) {
        // Eagle(0) beats Snake(2)
        ebool eagleVsSnake = FHE.and(FHE.eq(attacker, 0), FHE.eq(defender, 2));
        
        // Bear(1) beats Eagle(0)
        ebool bearVsEagle = FHE.and(FHE.eq(attacker, 1), FHE.eq(defender, 0));
        
        // Snake(2) beats Bear(1)
        ebool snakeVsBear = FHE.and(FHE.eq(attacker, 2), FHE.eq(defender, 1));
        
        // Type advantage
        ebool hasTypeAdvantage = FHE.or(FHE.or(eagleVsSnake, bearVsEagle), snakeVsBear);
        
        // Same type, compare health
        ebool sameType = FHE.eq(attacker, defender);
        ebool higherHealth = FHE.gt(attackerHealth, defenderHealth);
        
        return FHE.or(hasTypeAdvantage, FHE.and(sameType, higherHealth));
    }
    
    function getCardByIndex(uint8 playerIndex, euint8 cardIndex) internal returns (euint8) {
        euint8 result = players[playerIndex].cards[0].cardType;
        
        for (uint8 i = 0; i < 6; i++) {
            ebool isIndex = FHE.eq(cardIndex, i);
            result = FHE.select(isIndex, players[playerIndex].cards[i].cardType, result);
        }
        
        return result;
    }
    
    function getCardHealthByIndex(uint8 playerIndex, uint8 cardIndex) internal view returns (uint8) {
        require(cardIndex < 6, "Invalid card index");
        return players[playerIndex].cards[cardIndex].health;
    }
    
    function getCardAliveByIndex(uint8 playerIndex, uint8 cardIndex) internal view returns (bool) {
        require(cardIndex < 6, "Invalid card index");
        return players[playerIndex].cards[cardIndex].isAlive;
    }

    function isCardAliveAtIndex(uint8 playerIndex, euint8 cardIndex) internal view returns (ebool) {
        ebool result = FHE.asEbool(players[playerIndex].cards[0].isAlive);

        for (uint8 i = 1; i < 6; i++) {
            ebool isIndex = FHE.eq(cardIndex, i);
            result = FHE.select(isIndex, FHE.asEbool(players[playerIndex].cards[i].isAlive), result);
        }

        return result;
    }
    
    function updateCardStatus(euint8 result, euint8 card1Index, euint8 card2Index) internal {
        // Since isAlive is no longer encrypted, we need to decrypt the indices and result first
        // This requires a different approach - we'll update this in the battle logic instead

        // For now, store the encrypted battle result for later processing
        battleResults[currentRound] = result;
        FHE.allowThis(battleResults[currentRound]);
        FHE.allow(battleResults[currentRound], players[0].playerAddress);
        FHE.allow(battleResults[currentRound], players[1].playerAddress);
    }
    
    function updateAliveCount(uint8 playerIndex) internal {
        uint8 count = 0;

        for (uint8 i = 0; i < 6; i++) {
            if (players[playerIndex].cards[i].isAlive) {
                count++;
            }
        }

        players[playerIndex].aliveCount = count;
    }
    
    function checkGameEnd() internal {
        // Game end checking will be done externally by calling a view function
        // and then calling endGame() with decryption results
        // This is because we cannot decrypt inside the contract in FHEVM v0.7
    }
    
    function requestGameEndCheck() external view returns (uint8, uint8) {
        // Return both players' alive counts - no decryption needed since they're not encrypted
        return (players[0].aliveCount, players[1].aliveCount);
    }
    
    function endGame(address winner) external {
        require(gameState == GameState.Playing, "Game not in playing state");
        // In a real implementation, you would verify the winner through decryption oracle
        // For now, we trust the caller (this would be done by the frontend/relayer)
        
        gameState = GameState.Finished;
        emit GameEnded(winner);
    }
    
    // View functions
    function getPlayerCards(uint8 playerIndex) external view returns (euint8[6] memory types, uint8[6] memory healths, bool[6] memory aliveStatus) {
        require(playerIndex < 2, "Invalid player index");
        require(msg.sender == players[playerIndex].playerAddress, "Not authorized");

        for (uint8 i = 0; i < 6; i++) {
            types[i] = players[playerIndex].cards[i].cardType;
            healths[i] = players[playerIndex].cards[i].health;
            aliveStatus[i] = players[playerIndex].cards[i].isAlive;
        }
    }
    
    function getAliveCount(uint8 playerIndex) external view returns (uint8) {
        require(playerIndex < 2, "Invalid player index");
        require(msg.sender == players[playerIndex].playerAddress, "Not authorized");

        return players[playerIndex].aliveCount;
    }
    
    function getBattleResult(uint8 round) external view returns (euint8) {
        require(round < currentRound, "Round not finished");
        return battleResults[round];
    }
    
    function getGameInfo() external view returns (
        GameState state,
        uint8 round,
        uint8 joined,
        address player1,
        address player2
    ) {
        return (
            gameState,
            currentRound,
            playersJoined,
            players[0].playerAddress,
            players[1].playerAddress
        );
    }
}